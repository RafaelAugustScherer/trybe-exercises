# Block 38 - Data Structures II

# Hashmaps

A hashmap is a list of multiple groups of data, each located by a unique hash number, generated by a **hash function**. In Python, the `dict()` structure creates this behaviour.

- Advantage: Complexity of insertion or indexing is always `O(1)`;
- Disadvantage: Space complexity is higher.

Each space in the vector where the information is stored is called a bucket:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8a4273c8-c149-4bca-bc27-34af1961b812/Untitled.png)

To index a file, we provide the hash function with the insertion id and it will return the exact position of the bucket in the vector.

## Structure of a simple HashMap

With this structure we create a HashMap with the positions ranging from **0 to 9**, where each position is a **hash**.

```python
class HashMap:
    def __init__(self):
        self._buckets = [None for i in range(10)]

    def get_address(self, id_num):
        return id_num % 10

    def insert(self, employee):
        address = self.get_address(employee.id_num)
        self._buckets[address] = employee

    def get_value(self, id_num):
        address = self.get_address(id_num)
        return self._buckets[address].name
```

### Separate Chain

The problem of the simple example above is the **value collision**. Since we have a limited amount of 10 positions, different ids can result in the same hash meaning that it will **override** the current value.

One possible solution is **Separate Chain**, where multiple values are stored within the same hash position creating a list.

This would create yet another complexity problem when indexing the list within the hash, but the complexity is still lower than it would be in a normal list.

# Sets

Set is yet another list structure that is optimized for **both space and order complexity** but it is restricted in some aspects if compared to lists or dicts.

- **No duplicate elements allowed (unuseful for counting).**
- **Elements of any type but set are allowed to be in a set.**

```python
new_set = {1, 2, 3, 'str'}
```

## Operations

There are multiple logic operations to manage and better use a Set.

### Logic

```python
if 1 in new_set: # Check if element is present in set
		# Do something

new_set.add(2) # Add new value(s) to an existing set
new_set.remove(1) # Remove element; Error if doesnâ€™t exist
new_set.discard(1) # Remove element; No error
new_set.clear() # Clear set
```

### Compare

```python
new_set.isdisjoint(other_set) # True if there is no element in common between the set
new_set.issubset(other_set) # True if new_set is a subset of other_set
new_set.issuperset(other_set) # True if other_set is a subset of new_set
new_set == other_set # True if both sets contain the same elements
```

### Transform

```python
new_set.union(other_set) # return the union between these sets
new_set.intersection(other_set) # return the elements in common between these sets
new_set.difference(other_set) # return the elements that differ between these sets
new_set.symmetric_difference(other_set) # return elements present in new_set but not in other_set
```